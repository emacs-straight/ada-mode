;;; WisiToken grammar for Ada
;;
;; Author: Stephen Leake <stephe-leake@stephe-leake.org>
;; Maintainer: Stephen Leake <stephe-leake@stephe-leake.org>
;; Created: Sept 2012
;; Keywords: syntax
;;
%code copyright_license %{
;;  Copyright (C) 2013 - 2019 Free Software Foundation, Inc.

;;  This program is free software; you can redistribute it and/or
;;  modify it under the terms of the GNU General Public License as
;;  published by the Free Software Foundation; either version 3, or (at
;;  your option) any later version.
;;
;;  This software is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;  General Public License for more details.
;;
;;  You should have received a copy of the GNU General Public License
;;  along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
}%

%code actions spec post %{
   Partial_Parse_Active    : Boolean := False;
   Partial_Parse_Byte_Goal : WisiToken.Buffer_Pos := WisiToken.Buffer_Pos'Last;
}%

;;; Commentary:
;;
;; This is a wisi grammar file for the Ada language. It is derived
;; from the 2012 Ada Reference Manual (ARM) with Technical Corrigendum
;; 1, which is available as (info "(aarm2012)") or at
;; http://www.ada-auth.org/standards/ada12.html, under the license in
;; ada_license.text.
;;
;; see wisi.el for discussion of using the wisi parser for an
;; indentation engine.

%generate LALR elisp elisp
%generate LALR Ada_Emacs re2c Process
%generate LR1 Ada_Emacs text_rep re2c Process

%case_insensitive

%keyword ABS "abs"
%keyword ACCEPT "accept"
%keyword ABORT "abort"
%keyword ABSTRACT "abstract"
%keyword ACCESS "access"
%keyword ALIASED "aliased"
%keyword ALL "all"
%keyword AND "and"
%keyword ARRAY "array"
%keyword AT "at"
%keyword BEGIN "begin"
%keyword BODY "body"
%keyword CASE "case"
%keyword CONSTANT "constant"
%keyword DECLARE "declare"
%keyword DELAY "delay"
%keyword DELTA "delta"
%keyword DIGITS "digits"
%keyword DO "do"
%keyword ELSE "else"
%keyword ELSIF "elsif"
%keyword END "end"
%keyword ENTRY "entry"
%keyword EXCEPTION "exception"
%keyword EXIT "exit"
%keyword FOR "for"
%keyword FUNCTION "function"
%keyword GENERIC "generic"
%keyword GOTO "goto"
%keyword IF "if"
%keyword IN "in"
%keyword INTERFACE "interface"
%keyword IS "is"
%keyword LIMITED "limited"
%keyword LOOP "loop"
%keyword MOD "mod"
%keyword NEW "new"
%keyword NOT "not"
%keyword NULL "null"
%keyword OF "of"
%keyword OR "or"
%keyword OTHERS "others"
%keyword OUT "out"
%keyword OVERRIDING "overriding"
%keyword PACKAGE "package"
%keyword PRAGMA "pragma"
%keyword PRIVATE "private"
%keyword PROCEDURE "procedure"
%keyword PROTECTED "protected"
%keyword RAISE "raise"
%keyword RANGE "range"
%keyword RECORD "record"
%keyword REM "rem"
%keyword RENAMES "renames"
%keyword REQUEUE "requeue"
%keyword RETURN "return"
%keyword REVERSE "reverse"
%keyword SEPARATE "separate"
%keyword SELECT "select"
%keyword SOME "some"
%keyword SUBTYPE "subtype"
%keyword SYNCHRONIZED "synchronized"
%keyword TAGGED "tagged"
%keyword TASK "task"
%keyword TERMINATE "terminate"
%keyword THEN "then"
%keyword TYPE "type"
%keyword UNTIL "until"
%keyword USE "use"
%keyword WHEN "when"
%keyword WHILE "while"
%keyword WITH "with"
%keyword XOR "xor"

%token <left-paren> LEFT_PAREN "("
%token <right-paren> RIGHT_PAREN ")"

%token <punctuation> AMPERSAND "&"
%token <punctuation> BAR "|"
%token <punctuation> BOX "<>"
%token <punctuation> COLON ":"
%token <punctuation> COLON_EQUAL ":="
%token <punctuation> COMMA ","
%token <punctuation> DOT "."
%token <punctuation> DOT_DOT ".."
%token <punctuation> EQUAL "="
%token <punctuation> EQUAL_GREATER "=>"
%token <punctuation> GREATER ">"
%token <punctuation> GREATER_EQUAL ">="
%token <punctuation> GREATER_GREATER ">>"
%token <punctuation> LESS "<"
%token <punctuation> LESS_EQUAL "<="
%token <punctuation> LESS_LESS "<<"
%token <punctuation> MINUS "-"
%token <punctuation> PLUS "+"
%token <punctuation> SEMICOLON ";"
%token <punctuation> SLASH "/"
%token <punctuation> SLASH_EQUAL "/="
%token <punctuation> STAR "*"
%token <punctuation> STAR_STAR "**"

;; Support GNAT character coding in names and character and string
;; literals (see test/non_ascii.ads)
%re2c_regexp GNAT_Char_Coding %[ ("[\""[0-9A-Fa-f]+"\"]") ]%

;; re2c lookahead regular expression; this is not a character literal.
;; re2c does not allow combining | with /, so we need three tokens for
;; this (sigh).
%token <punctuation> TICK_1 "'"

%if lexer = re2c
%token <punctuation> TICK_2 %[ "'" / "('"([\x20-\U0010FFFF]|GNAT_Char_Coding)"'" ]%
%end if

%if lexer = elisp
%token <number> NUMERIC_LITERAL ada-wisi-number-p
%end if
%if lexer = re2c
;; This regexp allows a lot of things that are not Ada numeric
;; literals, but it's faster than a strictly conforming regexp. For
;; non-based literals, force a trailing integer so (1..Length) is
;; parsed correctly.
%token <number> NUMERIC_LITERAL %[ ([0-9])|([0-9][0-9eE._-]*[0-9])|([0-9]+"#"[0-9a-fA-F._-]+"#") ]%
%end if

;; non_grammar are not seen by the elisp lexer, but are needed by the re2c lexer
%non_grammar <non-reporting> WHITESPACE %[ [ \t]+ ]%

;; handle DOS or Unix newline
%non_grammar <new-line> NEW_LINE %[ [\x0a]|[\x0d][\x0a] ]%

;; Treat Ada comments, gnatprep preprocessor lines, and skeleton
;; placeholders as comments. x04 is EOF.
%non_grammar <comment> COMMENT %[ (("--"|"#if"|"#elsif"|"#else"|"#end")[^\n\x04]*)|("{"[^}]*"}") ]%

;; '$' for gnatprep symbols.
%token <symbol> IDENTIFIER
    %[ ([$a-zA-Z\x80-\U0010FFFF]|GNAT_Char_Coding)([0-9a-zA-Z_\x80-\U0010FFFF]|GNAT_Char_Coding)* ]%

%token <string-double> STRING_LITERAL %[ (["]([\x20-\x21\x23-\U0010FFFF]|GNAT_Char_Coding)*["])+ ]%

%token <string-single> CHARACTER_LITERAL %[ "'"([\x20-\U0010FFFF]|GNAT_Char_Coding)"'" ]%

%start compilation_unit_list

%elisp_face font-lock-constant-face
%elisp_face font-lock-function-name-face
%elisp_face font-lock-type-face
%elisp_face nil

%elisp_indent ada-indent-aggregate Ada_Indent_Aggregate
%elisp_indent ada-indent-renames Ada_Indent_Renames_0
%elisp_indent ada-indent-return Ada_Indent_Return_0
%elisp_indent ada-indent-record Ada_Indent_Record_0
%elisp_indent "ada-indent-record*" Ada_Indent_Record_1

;; Set McKenzie error recovery costs.
;;
;; We assume the user is typing new code more often than deleting or
;; changing old. Minimal_Complete reduces cost for insert, so the
;; default cost for insert, delete is the same. Often insert requires
;; push_back first, to get the parser in the right state, so push_back
;; is cheaper.
;;
;; We need a balance between Minimal_Complete and other solutions; if
;; Minimal_Complete is too cheap, it will complete the entire
;; compilation_Unit before the error point, when doing something else
;; at some point is better (see test/ada_mode-recover_29.adb, _15,
;; _24). On the other hand, doing lots of Minimal_Complete is very
;; common when writing new code (see test/ada_mode-recover_10.adb,
;; _error_during_resume_01). So we reduce the cost of inserting 'end
;; ;'.
;;
;; test/ada_mode-recover_change_name.adb needs 'ignore check fail' cost 2
;;
;; Default cost for insert, delete, push back/undo_reduce, ignore check fail.
%mckenzie_cost_default 4 4 2 2
%mckenzie_minimal_complete_cost_delta -3

;; END is cheaper, because it always requires at least one other
;; keyword to follow.
%mckenzie_cost_insert END 3

;; This cost is applied once, independent of token count.
%mckenzie_cost_matching_begin 3

;; Prefer doing more work at the current error point over moving
;; forward to a new one; there is normally only one real error point.
;; But not too much; test/ada_mode-recover_partial_02_lr1.adb requires
;; cost 2.
%mckenzie_cost_fast_forward 2

;; Handle converting 'if' to 'case' (and vice-versa), since that is a
;; common operation. See test/ada_mode-recover_29.adb. This also makes
;; inserting 'end if;' free; that's used a lot. But this defeats
;; Forbid_Minimal_Complete; see
;; test/ada_mode-recover_constant_as_statement_1.adb.
%mckenzie_cost_insert CASE 2
%mckenzie_cost_insert IF 2

;; Prefer undo_reduce over push_back; consider the code:
;;
;; loop
;;    if then
;;       statement;
;;    -- missing 'end if;'
;; end loop;
;; -- ^ error here
;;
;; Error recovery will insert 'end if;', after push_back or
;; undo_reduce of the handled_sequence_of_statements including
;; 'statement'. If it uses push_back, then 'end if;' is before
;; 'statement'; if undo_reduce, after, which is the desired result.;;
%mckenzie_cost_undo_reduce handled_sequence_of_statements 0
%mckenzie_cost_undo_reduce sequence_of_statements 0
%mckenzie_cost_undo_reduce sequence_of_statements_opt 0
%mckenzie_cost_undo_reduce declarative_part_opt 0

;; Missing or extra closing paren are common; missing handled by
;; Minimal_Complete.
%mckenzie_cost_delete RIGHT_PAREN 1

;; test/ada_mode-recover_29.adb requires 30_000
;; test/ada_mode-recover_partial_02_lr1.adb requires 45_000
%mckenzie_enqueue_limit 45_000

;; 4 required for test/ada_mode-recover_match_names.adb.
%mckenzie_check_limit 4

;; After finding 1 solution, only check 100 more before giving up.
;; Reduces solution time on complex errors.
%mckenzie_check_delta_limit 100

%end_names_optional_option End_Names_Optional

;; known conflicts that are resolved by generalized LALR parser
%conflict REDUCE/REDUCE in state abstract_limited_opt, abstract_limited_synchronized_opt on token NEW
%conflict REDUCE/REDUCE in state actual_parameter_part, actual_parameter_part  on token RIGHT_PAREN
%conflict REDUCE/REDUCE in state association_opt, expression_opt on token RIGHT_PAREN
%conflict REDUCE/REDUCE in state derived_type_definition, derived_type_definition  on token WITH
%conflict REDUCE/REDUCE in state full_type_declaration, full_type_declaration  on token NEW
%conflict REDUCE/REDUCE in state identifier_list, name on token COMMA
%conflict REDUCE/REDUCE in state name, direct_name on token USE
%conflict REDUCE/REDUCE in state paren_expression, paren_expression  on token RIGHT_PAREN
%conflict REDUCE/REDUCE in state primary, subtype_indication on token COMMA
%if parser = LALR
%conflict REDUCE/REDUCE in state primary, subtype_indication on token EQUAL_GREATER
%end if
%conflict REDUCE/REDUCE in state primary, subtype_indication on token RIGHT_PAREN
%conflict REDUCE/REDUCE in state range_list, discrete_subtype_definition on token COMMA
%conflict REDUCE/REDUCE in state range_list, discrete_subtype_definition on token RIGHT_PAREN
%conflict SHIFT/REDUCE in state abstract_subprogram_declaration, abstract_subprogram_declaration  on token IS
%conflict SHIFT/REDUCE in state accept_statement, accept_statement  on token LEFT_PAREN
%conflict SHIFT/REDUCE in state aspect_clause, name on token USE
%conflict SHIFT/REDUCE in state association_opt, name on token EQUAL_GREATER
%conflict SHIFT/REDUCE in state attribute_reference, attribute_designator  on token TICK_1
%conflict SHIFT/REDUCE in state block_label, identifier_list  on token COLON
%conflict SHIFT/REDUCE in state compilation_unit_list, compilation_unit_list  on token FOR
%conflict SHIFT/REDUCE in state declaration, declaration  on token CONSTANT
%conflict SHIFT/REDUCE in state expression_function_declaration, subprogram_specification on token IS
%conflict SHIFT/REDUCE in state formal_derived_type_definition, formal_derived_type_definition on token WITH
%conflict SHIFT/REDUCE in state generic_instantiation, generic_instantiation  on token IS
%conflict SHIFT/REDUCE in state generic_renaming_declaration, generic_formal_part  on token FUNCTION
%conflict SHIFT/REDUCE in state generic_renaming_declaration, generic_formal_part  on token PACKAGE
%conflict SHIFT/REDUCE in state generic_renaming_declaration, generic_formal_part  on token PROCEDURE
%conflict SHIFT/REDUCE in state membership_choice_list, relation  on token BAR
%conflict SHIFT/REDUCE in state name, attribute_designator  on token LEFT_PAREN
%conflict SHIFT/REDUCE in state null_procedure_declaration, subprogram_specification on token IS
%conflict SHIFT/REDUCE in state object_renaming_declaration, identifier_list  on token COLON
%conflict SHIFT/REDUCE in state package_body, package_body  on token IS
%conflict SHIFT/REDUCE in state parameter_specification, parameter_specification  on token NOT
%conflict SHIFT/REDUCE in state protected_body, protected_body  on token IS
%conflict SHIFT/REDUCE in state raise_expression, raise_expression on token WITH
%conflict SHIFT/REDUCE in state relation_and_list, expression  on token AND
%conflict SHIFT/REDUCE in state relation_and_then_list, expression  on token AND
%conflict SHIFT/REDUCE in state relation_or_else_list, expression  on token OR
%conflict SHIFT/REDUCE in state relation_or_list, expression  on token OR
%conflict SHIFT/REDUCE in state relation_xor_list, expression  on token XOR
%conflict SHIFT/REDUCE in state selected_component, attribute_designator  on token DOT
%conflict SHIFT/REDUCE in state task_body, task_body  on token IS
%conflict SHIFT/REDUCE in state wisitoken_accept, wisitoken_accept  on token FOR

%if lexer = re2c
%conflict SHIFT/REDUCE in state attribute_reference, attribute_designator  on token TICK_2
%end if

;;;; grammar rules
;;
;; The actions cache information in keywords that are significant for
;; indentation and motion.
;;
;; BNF copied from:
;;
;; (info "(aarm2012)Annex P" "*info Annex P*")
;; file:///C:/Projects/arm_info/org.adaic.arm_form/build/html/aarm2012/AA-P.html
;;
;; but listed in alphabetical order. Repeating constructs are
;; implemented with extra productions. Optional constructs are
;; implemented by repeated productions. Most names are simplified to
;; just "name".
;;
;; The EBNF in LRM Annex P is not LALR(1), so we use a generalized
;; LALR(1) parser.
;;
;; Annex P overloads several keywords as grammar elements; 'body',
;; 'pragma', some others. That matters in the generated Ada code. We
;; resolve this by appending _g to the grammar element name.
;;
;; To tolerate some invalid syntax during editing, we relax the
;; grammar, mainly by allowing many items to be empty.

abstract_limited_synchronized_opt
  : ABSTRACT LIMITED
  | ABSTRACT SYNCHRONIZED
  | ABSTRACT
  | LIMITED
  | SYNCHRONIZED
  | ;; empty
  ;

abstract_limited_opt
  : ABSTRACT LIMITED
  | LIMITED
  | ABSTRACT
  | ;; empty
  ;

abstract_tagged_limited_opt
  : ABSTRACT TAGGED LIMITED
  | ABSTRACT TAGGED
  | TAGGED LIMITED
  | TAGGED
  | LIMITED
  | ;; empty
  ;

abstract_subprogram_declaration
  : overriding_indicator_opt subprogram_specification IS ABSTRACT aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 statement-override 6 statement-end])
      (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken nil nil])))%
  ;

accept_statement
  : ACCEPT IDENTIFIER actual_parameter_part_opt parameter_profile_opt DO handled_sequence_of_statements END identifier_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 5 motion 9 statement-end])
      (wisi-containing-action 1 4) ;; for goto-declaration-start
      (wisi-containing-action 1 6) ;; ""
      (wisi-motion-action [1 5 [6 EXCEPTION WHEN] 9])
      (wisi-face-apply-action [2 nil font-lock-function-name-face 8 nil font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken [nil ada-indent] [ada-indent ada-indent] nil nil nil])))%
    %((wisi-match-names 2 8))%

  | ACCEPT IDENTIFIER actual_parameter_part_opt parameter_profile_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-containing-action 1 4) ;; for goto-declaration-start
      (wisi-face-apply-action [2 nil font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

;; same as access_type_definition for our purposes
access_definition
  : null_exclusion_opt ACCESS protected_opt PROCEDURE parameter_profile_opt
 ;; test/ada_mode-nomina.ads
 ;; type Procedure_Access_Type_8 is access
 ;;   protected procedure
 ;;     (A_Param : out Integer);
    %((wisi-indent-action [nil nil nil nil (wisi-anchored% 4 ada-indent-broken)]))%

  | null_exclusion_opt ACCESS protected_opt FUNCTION parameter_and_result_profile
 ;; test/ada_mode-nominal.ads
 ;; type Function_Access_Type_10 is access
 ;;   protected function
 ;;     (A_Param : in Float)
 ;;     return Standard.Float;
    %((wisi-indent-action [nil nil nil nil (wisi-anchored%- 4 ada-indent-broken)]))%

  | null_exclusion_opt ACCESS general_access_modifier_opt name
    %((wisi-face-apply-action [4 font-lock-function-name-face font-lock-type-face]))%
  ;

actual_parameter_part
  : LEFT_PAREN association_list RIGHT_PAREN
 ;; see note in test/ada_mode-parens.adb Local_10 about right paren indent.
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
 ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))
  | LEFT_PAREN conditional_quantified_expression RIGHT_PAREN
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
  ;

actual_parameter_part_opt
  : actual_parameter_part
  | ;; empty
  ;

;; All LEFT_PAREN in aggregate are indented 0 here. Special cases for
;; -1 are handled in 'primary'.
aggregate
  : LEFT_PAREN expression_opt WITH NULL RECORD RIGHT_PAREN ;; extension_aggregate with null record
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 1) nil nil (wisi-anchored 1 0)]))%
  | LEFT_PAREN expression_opt WITH association_list RIGHT_PAREN ;; extension_aggregate
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 1) [(wisi-anchored 1 1) (wisi-anchored 1 1)]
                         (wisi-anchored 1 0)]))%
  | LEFT_PAREN NULL RECORD RIGHT_PAREN

 ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))
  | LEFT_PAREN conditional_quantified_expression RIGHT_PAREN
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
  | LEFT_PAREN association_list RIGHT_PAREN ;; record_aggregate, named_array_aggregate, positional_array_aggregate
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
  ;

aliased_opt
  : ALIASED
  | ;; empty
  ;

and_interface_list_opt
  : AND interface_list
  | ;; empty
  ;

array_type_definition
  : ARRAY LEFT_PAREN index_subtype_definition_list RIGHT_PAREN OF component_definition
 ;; unconstrained_array_definition
    %((wisi-indent-action [nil nil (wisi-anchored 2 1) (wisi-anchored 2 0) nil nil]))%

  | ARRAY LEFT_PAREN discrete_subtype_definition_list RIGHT_PAREN OF component_definition
 ;; constrained_array_definition
    %((wisi-indent-action [nil nil (wisi-anchored 2 1) (wisi-anchored 2 0) nil nil]))%
  ;

aspect_clause
  : FOR attribute_reference USE expression_opt SEMICOLON ;; attribute_definition_clause
    %((wisi-statement-action [1 statement-start 5 statement-end]))%
  | enumeration_representation_clause
  | record_representation_clause
  | at_clause
  ;

;; aspect_mark ::= aspect_identifier[Class]

;; aspect_specification ::=
;;   with aspect_mark [=> aspect_definition] {,
;;        aspect_mark [=> aspect_definition] }
aspect_specification_opt
  : WITH association_list ;; overkill, but simpler.
    %((wisi-indent-action [nil ada-indent-broken]))%
  | ;; empty
  ;

assignment_statement
  : name COLON_EQUAL expression_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-containing-action 1 3)
      (wisi-indent-action [nil
                           ada-indent-broken
                           (wisi-hanging
                            (wisi-anchored% 2 ada-indent-broken)
                            (wisi-anchored% 3 ada-indent-broken))
                           nil])))%
  ;

association_opt
  : CHARACTER_LITERAL EQUAL_GREATER expression_opt ;; part of selector_name that does not overlap name
    %((wisi-indent-action [nil ada-indent-broken
                         [(wisi-anchored% 2 ada-indent-broken) (wisi-anchored% 2 ada-indent-broken)]]))%
  | CHARACTER_LITERAL EQUAL_GREATER BOX ;; from formal_package_association_list
  | discrete_choice_list EQUAL_GREATER expression_opt
 ;; We need wisi-hanging on expression_opt to recognize aspect_specification for a special case.
 ;; test/aspects.ads
 ;; with Pre => X > 10 and
 ;;             X < 50 and
 ;;             F (X),
 ;;   Post =>
 ;;     Y >= X and
 ;;     Some_Very_Verbose_Predicate (X, Y);
 ;;
 ;; test/indent.ads
 ;;   1 => --  Used to be aligned on "CSCL_Type'"
 ;;        --  aligned with previous comment.
 ;;     IO_CPU_Control_State_S_Pkg.CPU2_Fault_Status_Type'
 ;;       (Unused2  => 10,  -- Used to be aligned on "1 =>"
 ;;   requires '-' on wisi-hanging%-
    %((wisi-indent-action [(wisi-hanging nil ada-indent-broken)
                           ada-indent-broken
                           [(wisi-hanging%- (wisi-anchored% 2 ada-indent-broken)
                                            (wisi-anchored% 2 (* 2 ada-indent-broken)))
                            (wisi-hanging%- (wisi-anchored% 2 ada-indent-broken)
                                            (wisi-anchored% 2 (* 2 ada-indent-broken)))]]))%
  | discrete_choice_list EQUAL_GREATER BOX
    %((wisi-indent-action [(wisi-hanging nil ada-indent-broken) ada-indent-broken nil]))%
  | expression
 ;; test/ada_mode-parens.adb Hello
    %((wisi-indent-action [[(wisi-hanging nil ada-indent-broken) (wisi-hanging nil ada-indent-broken)]]))%
  | ;; empty
  ;

association_list
  : association_list COMMA association_opt
  | association_opt
  ;

asynchronous_select
  : SELECT triggering_alternative THEN ABORT sequence_of_statements_opt END SELECT SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 8 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 5)
      (wisi-indent-action [nil [ada-indent ada-indent] [nil ada-indent-broken] ada-indent-broken
                           [ada-indent ada-indent] nil nil nil])))%
  ;

at_clause
  : FOR direct_name USE AT expression_opt SEMICOLON
    %((wisi-statement-action [1 statement-start 6 statement-end]))%
  ;

attribute_reference : name tick attribute_designator ;

attribute_designator
;; IDENTIFIER LEFT_PAREN expression RIGHT_PAREN is redundant with name
  : name
  | ACCESS
  | DELTA
  | DIGITS
  | MOD
  ;

;; basic_declarative_item merged into declaration
;; basic_declaration merged into declaration

binary_adding_operator : PLUS | MINUS | AMPERSAND ; ;; + | - | &

block_label
  : IDENTIFIER COLON
    %((wisi-indent-action [ada-indent-label nil]))%
    %((wisi-propagate-name 1))%
  ;

block_label_opt
  : block_label
    %()%
    %((wisi-propagate-name 1))%
  | ;; empty
  ;

block_statement
  : block_label_opt DECLARE declarative_part_opt BEGIN handled_sequence_of_statements END identifier_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 misc 4 motion 8 statement-end])
      (wisi-containing-action 2 3)
      (wisi-containing-action 2 5)
      (wisi-motion-action [2 4 [5 EXCEPTION WHEN] 8])
      (wisi-indent-action [nil nil [ada-indent ada-indent] nil [ada-indent ada-indent] nil nil nil])))%
    %((wisi-match-names 1 7))%
  | block_label_opt BEGIN handled_sequence_of_statements END identifier_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 misc 6 statement-end])
      (wisi-containing-action 2 3)
      (wisi-motion-action [2 [3 EXCEPTION WHEN] 6])
      (wisi-indent-action [nil nil [ada-indent ada-indent] nil nil nil])))%
    %((wisi-match-names 1 5))%
  ;

body_g : proper_body | body_stub ;

body_stub
  : subprogram_body_stub | package_body_stub | task_body_stub | protected_body_stub ;

case_expression
  : CASE expression_opt IS case_expression_alternative_list
    %((wisi-indent-action [nil ada-indent-broken nil ada-indent-when]))%
  ;

case_expression_alternative
  : WHEN discrete_choice_list EQUAL_GREATER expression_opt
 ;; test/ada_mode-conditional_expressions.adb
 ;; when A =>
 ;;    J = 4
 ;;      or else M, --  test case from Piotr Trojanek
    %((wisi-indent-action [nil ada-indent-broken ada-indent-broken
                           (wisi-hanging (wisi-anchored% 1 ada-indent)
                                         (wisi-anchored% 1 (+ ada-indent ada-indent-broken)))]))%
  ;

case_expression_alternative_list
  : case_expression_alternative_list COMMA case_expression_alternative
    %((wisi-indent-action [nil [nil ada-indent-when] nil]))%
  | case_expression_alternative
  ;

case_statement
  : CASE expression_opt IS case_statement_alternative_list END CASE SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 7 statement-end])
      (wisi-containing-action 1 4)
      (wisi-motion-action [1 [4 WHEN] 7])
      (wisi-indent-action [nil ada-indent-broken nil [ada-indent-when ada-indent-when] nil nil nil])))%
  ;

case_statement_alternative
  : WHEN discrete_choice_list EQUAL_GREATER sequence_of_statements_opt
    %((progn
      (wisi-statement-action [1 motion])
      ;; ada-indent-when added in case_statement
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken [ada-indent ada-indent]])))%
  ;

;; We don't allow an empty list here; that leads to parallel parser
;; explosion in nested case statements. Note that ada-skel-case
;; inserts an empty when =>
case_statement_alternative_list
  : case_statement_alternative_list case_statement_alternative
  | case_statement_alternative
  ;

;; choice_expression use 'expression' to avoid conflicts

;; choice_relation* - use 'relation*', to avoid conflicts

;; Since we allow multiple compilation units in one parse, and don't
;; require a library_item in order to be user friendly, we don't need
;; a context_clause, since a list of context_items is just a
;; compilation_unit_list. Since context_item includes pragma, this
;; also allows a pragma following a compilation_unit.
;;
;; We allow additional items here for partial syntax in mako-ada
;; templates and grammar actions.
compilation_unit
  : with_clause
  | subunit
  | PRIVATE declaration
    %((wisi-indent-action [0 0]))%
  | declaration
  | statement
  ;

;; Compute indent for trailing comments.
compilation_unit_list
  : compilation_unit_list compilation_unit
    %((wisi-indent-action [0 [0 0]]))%
  | compilation_unit
    %((wisi-indent-action [[0 0]]))%
    %((wisi-terminate-partial-parse))%
  ;

component_clause
  : IDENTIFIER AT simple_expression RANGE simple_expression DOT_DOT simple_expression SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 8 statement-end])
      (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

component_clause_list
  : component_clause_list component_clause
  | component_clause
  ;

component_declaration
  : identifier_list COLON component_definition COLON_EQUAL expression_opt aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 1 3) ;; for goto-declaration-start
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken
                               (wisi-anchored% 4 ada-indent-broken)
                               ada-indent-broken nil])))%
  | identifier_list COLON component_definition aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-containing-action 1 3) ;; for goto-declaration-start
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

component_definition
  : ALIASED subtype_indication
  | subtype_indication
  | ALIASED access_definition
  | access_definition
  ;

component_item
  : component_declaration
  | aspect_clause
  ;

component_list
  : component_list component_item
  | component_list variant_part
  | component_item
  | variant_part
  | NULL SEMICOLON
    %((wisi-statement-action [1 statement-start 2 statement-end]))%
  ;

component_list_opt
  : component_list
  | ;; empty
  ;

compound_statement
  : if_statement
  | case_statement
  | loop_statement
  | block_statement
  | extended_return_statement
  | accept_statement
  | select_statement
  ;

conditional_entry_call
  : SELECT entry_call_alternative ELSE sequence_of_statements_opt END SELECT SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 7 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 4)
      (wisi-indent-action [nil [ada-indent ada-indent] nil [ada-indent ada-indent] nil nil nil])))%
  ;

conditional_quantified_expression
  : if_expression
  | case_expression
  | quantified_expression
  ;

constant_opt
  : CONSTANT
  | ;; empty
  ;

constraint
  : RANGE range_g ;; range_constraint
 ;; FIXME: | digits_constraint
 ;; FIXME: | delta_constraint
  | index_constraint
 ;; | discriminant_constraint same as aspect_specification
  ;

constraint_opt
  : constraint
  | ;; empty
  ;

;; context_item not needed; see compilation_unit

declaration
  : abstract_subprogram_declaration
  | aspect_clause
  | body_g
  | entry_declaration
  | exception_declaration
  | expression_function_declaration
  | generic_declaration
  | generic_instantiation
  | null_procedure_declaration
  | identifier_list COLON CONSTANT COLON_EQUAL expression_opt SEMICOLON ;; number_declaration
    %((progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-containing-action 1 5)
      (wisi-indent-action [(wisi-hanging nil ada-indent-broken) ada-indent-broken ada-indent-broken ada-indent-broken
                           (wisi-anchored% 4 ada-indent-broken) nil])))%
  | object_declaration
  | package_declaration
  | renaming_declaration
  | subprogram_declaration
  | subtype_declaration
  | type_declaration
  | use_clause
  ;

;; pragma_g is not a 'declaration' in ARM, but it must be in the
;; grammar. We don't include it in 'declaration', to avoid conflicts
;; with 'pragma_g' in statements via compilation_unit.
declarations
  : declarations declaration
  | declarations pragma_g
  | declaration
  | pragma_g
  ;

declarative_part_opt
  : declarations
  | ;; empty
  ;

;; declarative_item merged into declaration

delay_alternative
  : delay_statement sequence_of_statements_opt
  ;

delay_statement
  : DELAY UNTIL expression_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken nil])))%
  | DELAY expression_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-indent-action [nil ada-indent-broken nil])))%
  ;

derived_type_definition
  : abstract_limited_opt NEW name and_interface_list_opt WITH record_definition
    %((wisi-face-apply-action [3 font-lock-function-name-face font-lock-type-face]))%
  | abstract_limited_opt NEW name constraint_opt
    %((wisi-face-apply-action [3 font-lock-function-name-face font-lock-type-face]))%
  ;

direct_name
  : IDENTIFIER
  | STRING_LITERAL ;; operator_symbol
  ;

direct_name_opt
  : direct_name
  | ;; empty
  ;

discrete_choice
  : expression ;; includes 'name'
  | NOT NULL name ;; from subytpe_indication, excluding constructs covered by 'name'
  | range_g
  | OTHERS
  ;

discrete_choice_list
  : discrete_choice_list BAR discrete_choice
  | discrete_choice
  | ;; empty for skeleton indentation
  ;

 ;; discrete_range is the same as discrete_subtype_definition

 ;; discrete_range_list is the same as discrete_subtype_definition_list

discrete_subtype_definition : subtype_indication | range_g ;

discrete_subtype_definition_list
  : discrete_subtype_definition_list COMMA discrete_subtype_definition
  | discrete_subtype_definition
  ;

discriminant_part_opt
  : LEFT_PAREN BOX RIGHT_PAREN ;; (<>) unknown_discriminant_part
  | LEFT_PAREN discriminant_specification_list RIGHT_PAREN;; known_discriminant_part
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
  | ;; empty
  ;

discriminant_specification_opt
  : identifier_list COLON null_exclusion_opt_name_type COLON_EQUAL expression_opt
  | identifier_list COLON access_definition COLON_EQUAL expression_opt
  | identifier_list COLON null_exclusion_opt_name_type
  | identifier_list COLON access_definition
  | ;; empty
  ;

discriminant_specification_list
  : discriminant_specification_list SEMICOLON discriminant_specification_opt
  | discriminant_specification_opt
  ;

elsif_expression_item
  : ELSIF expression_opt THEN expression_opt
    %((progn
      (wisi-statement-action [1 motion 3 motion])
      (wisi-indent-action [nil [ada-indent-broken ada-indent-broken] nil ada-indent])))%
 ;; motion set in if_expression
  ;

elsif_expression_list
  : elsif_expression_list elsif_expression_item
  | elsif_expression_item
  ;

elsif_statement_item
  : ELSIF expression_opt THEN sequence_of_statements_opt
    %((progn
      (wisi-statement-action [1 motion 3 motion])
      (wisi-indent-action [nil [ada-indent-broken ada-indent-broken] nil [ada-indent ada-indent]])))%
 ;; motion set in if_statement
  ;

elsif_statement_list
  : elsif_statement_list elsif_statement_item
  | elsif_statement_item
  ;

entry_body
  : ENTRY IDENTIFIER entry_body_formal_part WHEN expression_opt
    IS declarative_part_opt BEGIN handled_sequence_of_statements END identifier_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 4 motion 6 motion 8 motion 12 statement-end])
        (wisi-name-action 2)
        (wisi-containing-action 1 3) ;; for goto-declaration-start
        (wisi-containing-action 1 7)
        (wisi-containing-action 1 9)
        (wisi-motion-action [1 4 6 8 12])
        (wisi-face-apply-action [2 nil font-lock-function-name-face 11 nil font-lock-function-name-face])

        ;; test/ada_mode-nominal.adb
        ;; entry E2
        ;;   (X : Integer)
        ;;   when Local_1 = 0 and not
        ;;     (Local_2 = 1)
        ;;
        ;; entry E3
        ;;   (X : Integer) when Local_1 = 0 and not
        ;;     (Local_2 = 1)
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken
                                 (wisi-anchored% 4 ada-indent-broken)
                                 nil [ada-indent ada-indent] nil [ada-indent ada-indent] nil nil nil])))%
    %((wisi-match-names 2 11))%
  ;

entry_body_formal_part
  : LEFT_PAREN FOR IDENTIFIER IN discrete_subtype_definition RIGHT_PAREN parameter_profile_opt
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 1) (wisi-anchored 1 1) (wisi-anchored 1 1)
                           (wisi-anchored 1 0) ada-indent-broken]))%
  | parameter_profile_opt
  ;

entry_call_alternative
  : procedure_call_statement sequence_of_statements_opt
  | name sequence_of_statements_opt ;; entry_call_statement
  ;

entry_declaration
  : overriding_indicator_opt ENTRY IDENTIFIER LEFT_PAREN discrete_subtype_definition RIGHT_PAREN
    parameter_profile_opt aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 2 motion 8 statement-end])
        (wisi-name-action 3)
        (wisi-containing-action 2 7) ;; for goto-declaration-start
        (wisi-face-apply-action [3 nil font-lock-function-name-face])
        (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken (wisi-anchored 4 1) (wisi-anchored 4 0)
                               ada-indent-broken nil nil])))%
  | overriding_indicator_opt ENTRY IDENTIFIER parameter_profile_opt aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 2 motion 6 statement-end])
        (wisi-name-action 3)
        (wisi-containing-action 2 4) ;; for goto-declaration-start
        (wisi-face-apply-action [3 nil font-lock-function-name-face])
        (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

enumeration_literal ;; enumeration_literal_specification
  : IDENTIFIER
  | CHARACTER_LITERAL
  ;

enumeration_literal_list
  : enumeration_literal_list COMMA enumeration_literal
  | enumeration_literal
  ;

enumeration_representation_clause
  : FOR name USE aggregate SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-face-apply-action [2 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

enumeration_type_definition
  : LEFT_PAREN enumeration_literal_list RIGHT_PAREN
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
  ;

exception_choice : name | OTHERS ;

exception_choice_list
  : exception_choice_list BAR exception_choice
  | exception_choice
  ;

;; FIXME: leaving out [renaming] [aspect_specification]
exception_declaration
  : identifier_list COLON EXCEPTION SEMICOLON
    %((wisi-statement-action [1 statement-start 4 statement-end]))%
  ;

exception_handler
  : WHEN IDENTIFIER COLON exception_choice_list EQUAL_GREATER
    sequence_of_statements_opt
    %((progn
      (wisi-statement-action [1 motion])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                             [ada-indent ada-indent]])))%
  | WHEN exception_choice_list EQUAL_GREATER sequence_of_statements_opt
    %((progn
      (wisi-statement-action [1 motion])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken [ada-indent ada-indent]])))%
  ;

exception_handler_list
  : exception_handler_list exception_handler
  | exception_handler
  | pragma_g
  ;

exception_handler_list_opt
  : exception_handler_list
  | ;; empty for user friendly
  ;

exit_statement
  : EXIT identifier_opt WHEN expression_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-indent-action [nil nil nil ada-indent-broken nil])))%
  | EXIT identifier_opt SEMICOLON
    %((wisi-statement-action [1 statement-start 3 statement-end]))%
  ;

expression
  : relation
  | relation_and_list
  | relation_and_then_list
  | relation_or_list
  | relation_or_else_list
  | relation_xor_list
  ;

expression_opt
  : expression
  | ;; empty for user friendly
  ;

expression_function_declaration
  : overriding_indicator_opt function_specification IS paren_expression aspect_specification_opt SEMICOLON
 ;; IS does not start a block, so it is not "motion".
 ;;
 ;; We override the cache on "function_specification", so
 ;; wisi-statement-action will handle an empty
 ;; "overriding_indicator_opt" correctly.
    %((progn
      (wisi-statement-action [1 statement-start 2 statement-override 6 statement-end])
      (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken nil nil])))%
  ;

extended_return_object_declaration
  : IDENTIFIER COLON aliased_opt constant_opt return_subtype_indication COLON_EQUAL expression_opt
    %((wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                           (wisi-anchored% 6 ada-indent-broken)]))%
  | IDENTIFIER COLON aliased_opt constant_opt return_subtype_indication
    %((wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken]))%
  ;

extended_return_object_declaration_opt
  : extended_return_object_declaration
  | ;; empty
  ;

extended_return_statement
  : RETURN extended_return_object_declaration_opt DO handled_sequence_of_statements END RETURN SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 7 statement-end])
      (wisi-containing-action 1 4)
      (wisi-motion-action [1 3 7])
      (wisi-indent-action [[nil ada-indent] ada-indent-broken nil [ada-indent ada-indent] nil nil nil])))%
  | RETURN extended_return_object_declaration SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 statement-end])))%
      ;; indent the same as a simple return statment
      ;; test/ada_mode-nominal.adb
      ;; return B : Integer :=
      ;;   (Local_Function);
      ;; (wisi-indent-action [nil nil nil]))
  ;

;; designator is merged with name

factor
  : primary STAR_STAR primary
  | primary
  | ABS primary
  | NOT primary
  ;

formal_object_declaration
  : identifier_list COLON mode_opt null_exclusion_opt name COLON_EQUAL
    expression_opt aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-face-apply-action [5 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                             (wisi-anchored% 6 ada-indent-broken) ada-indent-broken nil])))%
  | identifier_list COLON mode_opt access_definition COLON_EQUAL
    expression_opt aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 8 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                             (wisi-anchored% 5 ada-indent-broken) ada-indent-broken nil])))%
  | identifier_list COLON mode_opt null_exclusion_opt name aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-face-apply-action [5 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken nil])))%
  | identifier_list COLON mode_opt access_definition aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

formal_part
  : LEFT_PAREN parameter_specification_list RIGHT_PAREN
    %((progn
      (wisi-statement-action [1 misc]) ;; for ada-wisi-in-paramlist-p
      (wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)])))%
  ;

formal_subprogram_declaration
  : WITH subprogram_specification IS ABSTRACT subprogram_default aspect_specification_opt SEMICOLON
 ;; formal_abstract_subprogram_declaration
    %((progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  | WITH subprogram_specification IS subprogram_default aspect_specification_opt SEMICOLON
 ;; formal_concrete_subprogram_declaration
    %((progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  | WITH subprogram_specification IS ABSTRACT aspect_specification_opt SEMICOLON
 ;; formal_abstract_subprogram_declaration
    %((progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  | WITH subprogram_specification aspect_specification_opt SEMICOLON ;; formal_concrete_subprogram_declaration
    %((progn
      (wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-indent-action [nil nil ada-indent-broken nil])))%
  ;

formal_type_declaration
  : TYPE IDENTIFIER discriminant_part_opt IS formal_type_definition aspect_specification_opt SEMICOLON
 ;; formal_complete_type_declaration
    %((progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 1 5) ;; for goto-declaration-start
      (wisi-face-apply-action [2 nil font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken
                             ada-indent-broken ada-indent-broken nil])))%
  | TYPE IDENTIFIER discriminant_part_opt IS TAGGED aspect_specification_opt SEMICOLON
 ;; formal_incomplete_type_declaration
    %((progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-face-apply-action [2 nil font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken nil])))%
  | TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-face-apply-action [2 nil font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

formal_type_definition
  : abstract_tagged_limited_opt PRIVATE ;; formal_private_type_definition
  | formal_derived_type_definition
  | LEFT_PAREN BOX RIGHT_PAREN ;; formal_discrete_type_definition
  | RANGE BOX ;; formal_signed_integer_type_definition
  | MOD BOX ;; formal_modular_type_definition
  | DIGITS BOX ;; formal_floating_point_definition
  | DELTA BOX DIGITS BOX ;; formal_decimal_fixed_point_definition
  | DELTA BOX ;; formal_ordinary_fixed_point_definition
  | array_type_definition ;; formal_array_type_definition
  | access_definition ;; access_type_definition, formal_access_type_definition
  | interface_type_definition ;; formal_interface_type_definition
  ;

;; formal_derived_type_definition ::=
;;   [abstract] [limited | synchronized] new subtype_mark [[and interface_list]with private]
formal_derived_type_definition
  : abstract_limited_synchronized_opt NEW name and_interface_list_opt WITH PRIVATE
    %((wisi-face-apply-action [3 font-lock-function-name-face font-lock-type-face]))%
  | abstract_limited_synchronized_opt NEW name and_interface_list_opt
    %((wisi-face-apply-action [3 font-lock-function-name-face font-lock-type-face]))%
  ;

formal_package_declaration
  : WITH PACKAGE name IS NEW name formal_package_actual_part aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                 6 font-lock-function-name-face font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

formal_package_actual_part
  : LEFT_PAREN BOX RIGHT_PAREN ;; (<>)
  | ;; empty generic actual part

 ;; | LEFT_PAREN association_list RIGHT_PAREN
 ;; covered by name <empty formal_package_actual_part) in formal_package_declaration
 ;; covers others => <>
  ;

;; formal_package_association_list is merged into association_list to avoid reduce/reduce conflict

full_type_declaration
  : TYPE IDENTIFIER discriminant_part_opt IS type_definition aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 2)
        (wisi-containing-action 1 5) ;; for goto-declaration-start
        (wisi-face-apply-action [2 nil font-lock-type-face])

        ;; FIXME: indentation of comment after 'is' (and 'with' in
        ;; derived_type_definition) should be ada-indent-record-rel-type
        ;; if type_definition is a record. Worse if
        ;; ada-indent-comment-gnat is t. Need 'anchor to next line'.
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil nil])))%
  | task_type_declaration
  | protected_type_declaration
  ;

function_specification
  : FUNCTION name parameter_and_result_profile
    %((progn
        (wisi-statement-action [1 statement-start])
        (wisi-name-action 2)
        (wisi-containing-action 1 3) ;; for goto-declaration-start
        (wisi-face-apply-action [2 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken])))%
    %((wisi-propagate-name 2))%
  ;

general_access_modifier_opt
  : ALL
  | CONSTANT
  | ;; empty
  ;

;; generic_actual_part is not needed; see generic_instantiation

;; generic_association is merged into association

generic_declaration
  : generic_subprogram_declaration
  | generic_package_declaration
  ;

generic_formal_part
  : GENERIC generic_formal_parameter_declarations
    %((progn
      (wisi-statement-action [1 statement-start])
      (wisi-indent-action [nil ada-indent])))%
  | GENERIC
    %((wisi-statement-action [1 statement-start]))%
  ;

generic_formal_parameter_declarations
  : generic_formal_parameter_declarations generic_formal_parameter_declaration
  | generic_formal_parameter_declaration
  ;

generic_formal_parameter_declaration
  : formal_object_declaration
  | formal_type_declaration
  | formal_subprogram_declaration
  | formal_package_declaration
  | pragma_g
  | use_clause
  ;

generic_instantiation
 ;; name generic_actual_part is included in name as a function call
  : PACKAGE name IS NEW name aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 font-lock-function-name-face font-lock-function-name-face
                                   5 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil ada-indent-broken nil ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  | overriding_indicator_opt PROCEDURE name IS NEW name aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 2 motion 8 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   6 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  | overriding_indicator_opt FUNCTION name IS NEW name aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 2 motion 8 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   6 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil nil ada-indent-broken nil ada-indent-broken ada-indent-broken ada-indent-broken
                                 nil])))%
  ;

generic_package_declaration
  : generic_formal_part package_specification SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 motion 3 statement-end])
      (wisi-motion-action [1 2 3])
      (wisi-indent-action [[nil ada-indent] nil nil])))%
  ;

generic_renaming_declaration
  : GENERIC PACKAGE name RENAMES name aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   5 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  | GENERIC PROCEDURE name RENAMES name aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   5 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil nil ada-indent-broken (ada-indent-renames 3) ada-indent-broken ada-indent-broken
                                 nil])))%
  | GENERIC FUNCTION name RENAMES name aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   5 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil nil ada-indent-broken (ada-indent-renames 3) ada-indent-broken ada-indent-broken
                                 nil])))%
  ;

generic_subprogram_declaration
  : generic_formal_part subprogram_specification aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 motion 4 statement-end])
      (wisi-motion-action [1 2 4])))%
  ;

goto_label
  : LESS_LESS IDENTIFIER GREATER_GREATER
    %((progn
      (wisi-face-apply-action [2 nil font-lock-constant-face])
      (wisi-indent-action [ada-indent-label nil nil])))%
  ;

handled_sequence_of_statements
  : sequence_of_statements_opt EXCEPTION exception_handler_list_opt
    %((progn
      (wisi-statement-action [2 motion])
      (wisi-indent-action [[nil nil]
                           (- ada-indent)
                           [(- ada-indent-when ada-indent) (- ada-indent-when ada-indent)]])))%
  | sequence_of_statements_opt
  ;

identifier_list
  : identifier_list COMMA IDENTIFIER
    %((progn
        (wisi-name-action 3)
        (wisi-indent-action [nil nil ada-indent-broken])))%
  | IDENTIFIER
    %((wisi-name-action 1))%
  ;

identifier_opt
  : IDENTIFIER
    %()%
    %((wisi-propagate-name 1))%
  | ;; empty
  ;

if_expression
  : IF expression_opt THEN expression_opt elsif_expression_list ELSE expression_opt
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 6 motion])
      (wisi-containing-action 1 2)
      (wisi-motion-action [1 3 [5 ELSIF THEN] 6])
      (wisi-indent-action [nil [ada-indent-broken ada-indent-broken] nil ada-indent nil nil ada-indent])))%
  | IF expression_opt THEN expression_opt ELSE expression_opt
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 5 motion])
      (wisi-containing-action 1 2)
      (wisi-motion-action [1 3 5])
      (wisi-indent-action [nil [ada-indent-broken ada-indent-broken] nil ada-indent nil ada-indent])))%
  | IF expression_opt THEN expression_opt elsif_expression_list
    %((progn
      (wisi-statement-action [1 statement-start 3 motion])
      (wisi-containing-action 1 2)
      (wisi-motion-action [1 3 [5 ELSIF THEN]])
      (wisi-indent-action [nil [ada-indent-broken ada-indent-broken] nil ada-indent nil])))%
  | IF expression_opt THEN expression_opt
    %((progn
      (wisi-statement-action [1 statement-start 3 motion])
      (wisi-containing-action 1 2)
      (wisi-motion-action [1 3])
      (wisi-indent-action [nil [ada-indent-broken ada-indent-broken] nil ada-indent])))%
  ;

if_statement
  : IF expression_opt THEN sequence_of_statements_opt elsif_statement_list ELSE
    sequence_of_statements_opt END IF SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 6 motion 10 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 4)
      (wisi-containing-action 1 5)
      (wisi-containing-action 1 7)
      (wisi-motion-action [1 3 [5 ELSIF THEN] 6 10])
      (wisi-indent-action [nil [(wisi-hanging% ada-indent-broken (* 2 ada-indent-broken))
                              ada-indent-broken]
                             nil
                             [ada-indent ada-indent] nil nil
                             [ada-indent ada-indent] nil nil nil])))%
  | IF expression_opt THEN sequence_of_statements_opt ELSE sequence_of_statements_opt END IF SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 5 motion 9 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 4)
      (wisi-containing-action 1 6)
      (wisi-motion-action [1 3 5 9])
      (wisi-indent-action [nil [(wisi-hanging% ada-indent-broken (* 2 ada-indent-broken))
                              ada-indent-broken]
                             nil
                             [ada-indent ada-indent] nil
                             [ada-indent ada-indent] nil nil nil])))%
  | IF expression_opt THEN sequence_of_statements_opt elsif_statement_list END IF SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 8 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 4)
      (wisi-containing-action 1 5)
      (wisi-motion-action [1 3 [5 ELSIF THEN] 8])
      (wisi-indent-action [nil [(wisi-hanging% ada-indent-broken (* 2 ada-indent-broken))
                              ada-indent-broken]
                             nil
                             [ada-indent ada-indent] nil nil nil nil])))%
  | IF expression_opt THEN sequence_of_statements_opt END IF SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 7 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 4)
      (wisi-motion-action [1 3 7])
      (wisi-indent-action [nil [(wisi-hanging% ada-indent-broken (* 2 ada-indent-broken))
                              ada-indent-broken]
                             nil
                             [ada-indent ada-indent] nil nil nil])))%
  ;

incomplete_type_declaration
  : TYPE IDENTIFIER discriminant_part_opt IS TAGGED SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 6 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  | TYPE IDENTIFIER discriminant_part_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 3 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken nil])))%
  ;

index_constraint
  : LEFT_PAREN discrete_subtype_definition_list RIGHT_PAREN
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
  ;

index_subtype_definition : name RANGE BOX ;

index_subtype_definition_list
  : index_subtype_definition_list COMMA index_subtype_definition
  | index_subtype_definition
  ;

interface_list
  : interface_list AND name
    %((wisi-face-apply-action [3 font-lock-function-name-face font-lock-type-face]))%
  | name
    %((wisi-face-apply-action [1 font-lock-function-name-face font-lock-type-face]))%
  ;

interface_type_definition
  : LIMITED INTERFACE AND interface_list
  | TASK INTERFACE AND interface_list
  | PROTECTED INTERFACE AND interface_list
  | SYNCHRONIZED INTERFACE AND interface_list
  | LIMITED INTERFACE
  | TASK INTERFACE
  | PROTECTED INTERFACE
  | SYNCHRONIZED INTERFACE
  | INTERFACE
;

iteration_scheme
  : WHILE expression_opt
    %((wisi-indent-action [nil [ada-indent-broken ada-indent-broken]]))%
  | FOR iterator_specification_opt
    %((wisi-indent-action [nil [ada-indent-broken ada-indent-broken]]))%
  ;

iterator_specification
 ;; also loop_parameter_specification, to avoid redundancy bewteen
 ;; iterator_name and discrete_subtype_definition; both can be just
 ;; 'name'. For example, a name could be either
 ;; 'Package_Name.Type_Name' from a loop_parameter_specification, or
 ;; "Object_Name.Iterator' from iterator_specification.
 ;;
 ;; That means both get marked with the same face, when they should
 ;; not be. If we include the conflict to get different face actions,
 ;; it will be resolved by identical stacks, one will be terminated at
 ;; random, and the wrong face action might still be applied. This can
 ;; only be fixed with true name resolution, so we remove any faces
 ;; that have been applied.
 ;;
  : IDENTIFIER COLON subtype_indication OF REVERSE name
  | IDENTIFIER COLON subtype_indication OF name
  | IDENTIFIER IN REVERSE discrete_subtype_definition
    %((wisi-face-remove-action [4]))%

 ;; The following can only be iterator_specifications. The name could
 ;; include a package name, but we can't tell that without full name
 ;; resolution.
  | IDENTIFIER OF REVERSE name
  | IDENTIFIER OF name

  | IDENTIFIER IN discrete_subtype_definition
    %((wisi-face-remove-action [3]))%
  ;

iterator_specification_opt
  : iterator_specification
  | ;; empty
  ;

;; library_*  not needed; 'declaration' in compilation_unit

loop_statement
  : block_label_opt iteration_scheme LOOP sequence_of_statements_opt END LOOP identifier_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 misc 3 motion 8 statement-end])
      (wisi-containing-action 2 4)
      (wisi-motion-action [2 3 8])
      (wisi-indent-action [nil nil nil [ada-indent ada-indent] nil nil nil nil])))%
    %((wisi-match-names 1 7))%
  | block_label_opt LOOP sequence_of_statements_opt END LOOP identifier_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 misc 7 statement-end])
      (wisi-containing-action 2 3)
      (wisi-indent-action [nil nil [ada-indent ada-indent] nil nil nil nil])))%
    %((wisi-match-names 1 6))%
  ;

membership_choice_list
  : membership_choice_list BAR membership_choice
  | membership_choice
  ;

membership_choice
  : simple_expression
 ;; ARM has choice_expression here, but that leads to a shift/reduce conflict, because of the following productions:
 ;; membership_choice_list => membership_choice => choice_expression => choice_relation_and_list
 ;; relation => simple_expression IN choice_relation_and_list
 ;; thus 'choice_relation_and_list AND' could be followed by relation (=> reduce) or choice_relation (=> shift)
 ;; This only occurs in legal Ada in expressions such as 'True in 1 and 3'; not useful, so we leave it out.
  | range_g
 ;;  | name ;; subtype_mark - also covered by simple_expression; avoid reduce/reduce conflict
  ;

mod_clause_opt
  : AT MOD expression_opt SEMICOLON
  | ;; empty
  ;

mode_opt
  : IN
  | IN OUT
  | OUT
  | ;; empty
  ;

multiplying_operator : STAR | SLASH | MOD | REM ; ;; * | / | mod | rem

name_list
  : name_list COMMA name
  | name
  ;

name
 ;; ARM has name ( discrete_subtype_definition ) here, but that's
 ;; partly redundant with name actual_parameter_part, and partly with
 ;; subtype_indication; this is the part that is not redundant.
  : name LEFT_PAREN range_list RIGHT_PAREN ;; slice or constraint
 ;; test/ada_mode_nominal.ads Access_Unconstrained_Array_Type_1
 ;; test/ada_mode-parens.adb
 ;; Slice_1
 ;;   (1,
 ;;    C
 ;;      (1 .. 2));
 ;;
 ;; tests/g-comlin.adb
 ;; return CL.Argument (The_Switch.Arg_Num)
 ;;   (The_Switch.First ..
 ;;      The_Switch.Last);
    %((wisi-indent-action [nil
                         (wisi-anchored% 1 ada-indent-broken)
                         (wisi-hanging (wisi-anchored 2 1)
                                       (wisi-anchored 2 (+ 1 ada-indent-broken)))
                         (wisi-anchored 2 0)]))%

  | name actual_parameter_part
 ;; type_conversion, function_call, procedure call, generic
 ;; instantiation, indexed_component.
 ;;
 ;; test/ada_mode-parens.adb
 ;; No_Conditional_Set : constant Ada.Strings.Maps.Character_Set :=
 ;;   Ada.Strings.Maps."or"
 ;;     (Ada.Strings.Maps.To_Set (' '),
 ;;
 ;; Local_11 : Local_11_Type := Local_11_Type'
 ;;   (A => Integer
 ;;      (1.0),
 ;; indented by association
 ;;
 ;;test/hanging.adb; sets ada-indent-hanging-rel-exp: t
 ;; X_Long_Name
 ;;   := F_Long_Name
 ;;        (A => True,
 ;;         B => True);
    %((progn
      (wisi-statement-action [1 misc])
      (wisi-containing-action 1 2)
      (wisi-indent-action [nil (if ada-indent-hanging-rel-exp
                                 (wisi-anchored 1 ada-indent-broken)
                               (wisi-anchored% 1 ada-indent-broken))])))%

  | selected_component ;; starts with name
    %()%
    %((wisi-propagate-name 1))%

  | attribute_reference ;; starts with name
  | qualified_expression ;; starts with name

  | IDENTIFIER ;; from direct_name
 ;; marking this for possible later face-apply, to prevent applying
 ;; face to the aggregate of an allocator, and other similar cases.
 ;; test/ada_mode-nominal.adb
 ;;    Object_3 : access Record_Type_3 := new Record_Type_3 (...)
    %((wisi-face-mark-action [1 suffix]))%
    %((wisi-propagate-name 1))%

  | CHARACTER_LITERAL ;; only in an expression, so no type or function-name face

  | STRING_LITERAL ;; operator_symbol, designator
    %()%
    %((wisi-propagate-name 1))%

  ;; | explicit_dereference in selected_component
  ;; | indexed_component same as 'name actual_parameter_part' above
  ;; | generalized_reference same as 'name'
  ;; | generalized_indexing same as 'indexed_component'
  ;

name_opt
  : name
    %()%
    %((wisi-propagate-name 1))%
  | ;; empty
  ;

null_exclusion_opt
  : NOT NULL
  | ;; empty
  ;

;; use _only_ to avoid a conflict between name and null_exclusion_opt; name must be a type
null_exclusion_opt_name_type
  : IDENTIFIER
    %((wisi-face-apply-action [1 nil font-lock-type-face]))%
  | selected_component
    %((wisi-face-apply-action [1 font-lock-function-name-face font-lock-type-face]))%
  | NOT NULL IDENTIFIER
    %((wisi-face-apply-action [3 nil font-lock-type-face]))%
  | NOT NULL selected_component
    %((wisi-face-apply-action [3 font-lock-function-name-face font-lock-type-face]))%
  ;

null_procedure_declaration
  : overriding_indicator_opt procedure_specification IS NULL aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 statement-override 6 statement-end])
      (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

object_declaration
  : identifier_list COLON aliased_opt constant_opt subtype_indication COLON_EQUAL
    expression_opt aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-containing-action 1 7)
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                             (wisi-anchored%- 6 ada-indent-broken) ada-indent-broken nil])))%
  | identifier_list COLON aliased_opt constant_opt access_definition COLON_EQUAL
    expression_opt aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-containing-action 1 5) ;; for goto-declaration-start
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                             (wisi-anchored% 6 ada-indent-broken) ada-indent-broken nil])))%
  | identifier_list COLON aliased_opt constant_opt array_type_definition COLON_EQUAL
    expression_opt aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-containing-action 1 5) ;; for goto-declaration-start
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                             (wisi-anchored% 6 ada-indent-broken) ada-indent-broken nil])))%
  | identifier_list COLON aliased_opt constant_opt subtype_indication aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken nil])))%
  | identifier_list COLON aliased_opt constant_opt access_definition aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 1 5) ;; for goto-declaration-start
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken nil])))%
  | identifier_list COLON aliased_opt constant_opt array_type_definition aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 1 5) ;; for goto-declaration-start
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken nil])))%
  | single_task_declaration
  | single_protected_declaration
  ;

object_renaming_declaration
  : IDENTIFIER COLON null_exclusion_opt name RENAMES name aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 8 statement-end])
        (wisi-name-action 1)
        (wisi-face-apply-action [4 font-lock-function-name-face font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                                 ada-indent-broken ada-indent-broken nil])))%
  | IDENTIFIER COLON access_definition RENAMES name aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 1)
        (wisi-containing-action 1 3) ;; for goto-declaration-start
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                                 ada-indent-broken nil])))%
  | IDENTIFIER COLON EXCEPTION RENAMES name aspect_specification_opt SEMICOLON ;; exception_renaming_declaration
    %((progn
        (wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 1)
        (wisi-face-apply-action [5 font-lock-function-name-face nil])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                                 ada-indent-broken nil])))%
  ;

;; operator_symbol is STRING_LITERAL, in name

overriding_indicator_opt
  : NOT OVERRIDING
    %((wisi-statement-action [1 statement-start 2 statement-override]))%
  | OVERRIDING
    %((wisi-statement-action [1 statement-start]))%
  | ;; empty - following keyword is statement-start
  ;

package_body
  : PACKAGE BODY name aspect_specification_opt IS declarative_part_opt
    BEGIN handled_sequence_of_statements END name_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 5 motion 7 motion 11 statement-end])
        (wisi-name-action 3)
        (wisi-containing-action 1 6)
        (wisi-containing-action 1 8)
        (wisi-motion-action [1 5 7 [8 EXCEPTION WHEN] 11])
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   10 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken nil nil [ada-indent ada-indent]
                             nil [ada-indent ada-indent] nil ada-indent-broken nil])))%
    %((wisi-match-names 3 10))%

  | PACKAGE BODY name aspect_specification_opt IS declarative_part_opt END name_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 5 motion 9 statement-end])
        (wisi-name-action 3)
        (wisi-containing-action 1 6)
        (wisi-motion-action [1 5 9])
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   8 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil [ada-indent ada-indent] nil
                                 nil nil])))%
    %((wisi-match-names 3 8))%
  ;

package_body_stub
  : PACKAGE BODY name IS SEPARATE aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken nil ada-indent-broken ada-indent-broken nil])))%
  ;

package_declaration
  : package_specification SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 statement-end])
      (wisi-motion-action [[1 PRIVATE] 2])))%
  ;

package_renaming_declaration
  : PACKAGE name RENAMES name aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 6 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 font-lock-function-name-face font-lock-function-name-face
                                   4 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

package_specification
  : PACKAGE name aspect_specification_opt IS declarative_part_opt PRIVATE declarative_part_opt END name_opt
    %((progn
        (wisi-statement-action [1 statement-start 4 motion 6 motion])
        (wisi-name-action 2)
        (wisi-containing-action 1 4)
        (wisi-containing-action 4 5) ;; for goto-declarative-region-start
        (wisi-containing-action 1 7)
        (wisi-motion-action [1 4 6])
        (wisi-face-apply-action [2 font-lock-function-name-face font-lock-function-name-face
                                   9 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken nil [ada-indent ada-indent] nil
                             [ada-indent ada-indent] nil nil])))%
    %((wisi-match-names 2 9))%
  | PACKAGE name aspect_specification_opt IS declarative_part_opt END name_opt
    %((progn
      (wisi-statement-action [1 statement-start 4 motion])
      (wisi-name-action 2)
      (wisi-containing-action 1 4)
      (wisi-containing-action 4 5) ;; for goto-declarative-region-start
      (wisi-motion-action [1 4])
      (wisi-face-apply-action [2 font-lock-function-name-face font-lock-function-name-face
                                 7 font-lock-function-name-face font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken nil [ada-indent ada-indent] nil nil])))%
    %((wisi-match-names 2 7))%
  ;

parameter_and_result_profile
  : formal_part result_profile
    %((wisi-indent-action [nil (ada-indent-return 1 0)]))%
  | result_profile
  ;

;; parameter_association is merged into association
;; parameter_association_list is merged into association_list

parameter_profile_opt
  : formal_part
  | ;; empty
  ;

parameter_specification
  : identifier_list COLON aliased_opt mode_opt null_exclusion_opt name COLON_EQUAL expression_opt
    %((progn
      (wisi-face-apply-action [6 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                             ada-indent-broken ada-indent-broken (wisi-anchored% 7 ada-indent-broken)])))%
  | identifier_list COLON aliased_opt mode_opt null_exclusion_opt name
    %((progn
      (wisi-face-apply-action [6 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                             ada-indent-broken])))%
  | identifier_list COLON aliased_opt access_definition COLON_EQUAL expression_opt
    %((wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                           (wisi-anchored% 5 ada-indent-broken)]))%
  | identifier_list COLON aliased_opt access_definition
    %((wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken]))%
  | ;; empty
  ;

parameter_specification_list
  : parameter_specification_list SEMICOLON parameter_specification
    %((wisi-statement-action [2 motion]))% ;; not integrated with higher level motion; just a local stopping point
  | parameter_specification
  ;

paren_expression
  : LEFT_PAREN expression_opt RIGHT_PAREN
 ;;test/ada_mode-parens.ads
 ;; function Expression_Function_1 (V : Integer) return Boolean
 ;;   is ((V = V and then True)
 ;;         or else True);
    %((wisi-indent-action [nil
                         (wisi-hanging (wisi-anchored 1 1)
                                       (wisi-anchored 1 (+ 1 ada-indent-broken)))
                         (wisi-anchored 1 0)]))%

  | LEFT_PAREN association_list RIGHT_PAREN
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)]))%

 ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))
  | LEFT_PAREN conditional_quantified_expression RIGHT_PAREN
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
  ;

pragma_g
  : PRAGMA IDENTIFIER LEFT_PAREN association_list RIGHT_PAREN SEMICOLON
 ;; ARM has 'pragma_argument_association'; this is a superset, and reduces redundancy
    %((progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-face-apply-action [2 nil font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken (wisi-anchored 3 1) (wisi-anchored 3 0) nil])))%
 ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))
  | PRAGMA IDENTIFIER LEFT_PAREN conditional_quantified_expression RIGHT_PAREN SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-face-apply-action [2 nil font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken (wisi-anchored 3 1) (wisi-anchored 3 0) nil])))%
  | PRAGMA IDENTIFIER SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-face-apply-action [2 nil font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken nil])))%
  ;

;; prefix is name

primary
  : NUMERIC_LITERAL
    %((wisi-face-apply-action [1 nil font-lock-constant-face]))%
  | NULL
 ;; | STRING_LITERAL in name
  | aggregate
    %((wisi-indent-action [(ada-indent-aggregate)]))%
  | name
  | NEW name
 ;; allocator, FIXME: leaving out subpool_specification.
    %((wisi-face-apply-action [2 font-lock-function-name-face font-lock-type-face]))%
 ;; | LEFT_PAREN expression RIGHT_PAREN ;; covered by aggregate
 ;; | LEFT_PAREN conditional_quantified_expression RIGHT_PAREN ; covered by aggregate
  ;

private_extension_declaration
  : TYPE IDENTIFIER discriminant_part_opt IS abstract_limited_synchronized_opt NEW
    subtype_indication and_interface_list_opt WITH PRIVATE aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 12 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil nil])))%
  ;

private_type_declaration
  : TYPE IDENTIFIER discriminant_part_opt IS abstract_tagged_limited_opt PRIVATE aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 8 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken nil ada-indent-broken ada-indent-broken nil
                                 nil])))%
  ;

procedure_call_statement
  : name SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 statement-end])
      (wisi-indent-action [(wisi-hanging nil ada-indent-broken) nil])))%
  ;

procedure_specification
  : PROCEDURE name parameter_profile_opt
    %((progn
        (wisi-statement-action [1 statement-start])
        (wisi-name-action 2)
        (wisi-containing-action 1 3) ;; for goto-declaration-start
        (wisi-face-apply-action [2 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken])))%
    %((wisi-propagate-name 2))%
  ;

proper_body
  : subprogram_body
  | package_body
  | task_body
  | protected_body
  ;

protected_body
  : PROTECTED BODY IDENTIFIER aspect_specification_opt IS protected_operation_item_list_opt END identifier_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 5 motion 9 statement-end])
        (wisi-name-action 3)
        (wisi-containing-action 1 6)
        (wisi-motion-action [1 5 9])
        (wisi-face-apply-action [3 nil font-lock-type-face 8 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken nil nil ada-indent nil nil nil])))%
    %((wisi-match-names 3 8))%
  ;

protected_body_stub
  : PROTECTED BODY IDENTIFIER IS SEPARATE aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken nil])))%
  ;

protected_definition
  : declarative_part_opt PRIVATE declarative_part_opt END identifier_opt
    %((progn
      (wisi-statement-action [2 motion])
      (wisi-face-apply-action [5 nil font-lock-type-face])
      (wisi-indent-action [[ada-indent ada-indent] nil [ada-indent ada-indent] nil nil])))%
    %((wisi-propagate-name 5))%

  | declarative_part_opt END identifier_opt
    %((progn
      (wisi-face-apply-action [3 nil font-lock-type-face])
      (wisi-indent-action [[ada-indent ada-indent] nil nil])))%
    %((wisi-propagate-name 3))%
  ;

protected_operation_item
  : subprogram_declaration
  | subprogram_body
  | entry_body
  | expression_function_declaration
  | null_procedure_declaration
  | aspect_clause
  ;

protected_operation_item_list
  : protected_operation_item_list protected_operation_item
  | protected_operation_item
  ;

protected_operation_item_list_opt
  : protected_operation_item_list
  | ;; empty
  ;

protected_opt
  : PROTECTED
  | ;; empty
  ;

protected_type_declaration
  : PROTECTED TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt IS
    NEW interface_list WITH protected_definition SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 6 motion 9 motion 11 statement-end])
        (wisi-name-action 3)
        (wisi-containing-action 1 10)
        (wisi-motion-action [1 6 [10 PRIVATE] 11])
        (wisi-face-apply-action [3 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil nil
                               ada-indent-broken ada-indent-broken ada-indent-broken nil nil])))%
    %((wisi-match-names 3 10))%
  | PROTECTED TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt IS protected_definition SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 6 motion 8 statement-end])
        (wisi-name-action 3)
        (wisi-containing-action 1 7)
        (wisi-motion-action [1 6 [7 PRIVATE] 8])
        (wisi-face-apply-action [3 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil [nil ada-indent] nil nil])))%
    %((wisi-match-names 3 7))%
  ;

;; protected_operation_declaration merged into declaration

qualified_expression
  : name tick aggregate
    %((progn
      (wisi-face-apply-action [1 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil nil (if ada-indent-hanging-rel-exp
                                   (wisi-anchored 1 ada-indent-broken)
                                 (wisi-anchored% 1 ada-indent-broken))])))%
    ;

quantified_expression
  : FOR quantifier iterator_specification EQUAL_GREATER expression_opt
    %((wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken (wisi-anchored% 4 ada-indent-broken)]))%
  ;

quantifier : ALL | SOME ;

raise_expression
  : RAISE name WITH expression_opt
    %((wisi-indent-action [nil ada-indent-broken ada-indent-broken (wisi-anchored% 3 ada-indent-broken)]))%
  | RAISE name
  ;

raise_statement
  : RAISE name WITH expression_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 4 motion 5 statement-end])
      (wisi-containing-action 1 4)
      ;; test/ada_mode-nominal.adb
      ;; raise Constraint_Error with
      ;;   "help " &
      ;;   "me!";
      ;;
      ;; raise Constraint_Error
      ;;   with Integer'Image (1) &
      ;;   "help!";
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken (wisi-anchored% 3 ada-indent-broken) nil])))%
  | RAISE name SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-indent-action [nil ada-indent-broken nil])))%
  | RAISE SEMICOLON
    %((wisi-statement-action [1 statement-start 2 statement-end]))%
  ;

range_g
  : name tick RANGE LEFT_PAREN expression_opt RIGHT_PAREN ;; range_attribute_reference
    %((wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken (wisi-anchored 4 1) (wisi-anchored 4 0)]))%
  | name tick RANGE ;; range_attribute_reference
  | simple_expression DOT_DOT simple_expression
  ;

range_list
  : range_list COMMA range_g
  | range_g
  ;

real_range_specification_opt
  : RANGE simple_expression DOT_DOT simple_expression
  | ;; empty
  ;

record_definition
  : RECORD component_list_opt END RECORD
    %((wisi-indent-action [[(ada-indent-record* 'TYPE 1 0) (ada-indent-record* 'TYPE 1 ada-indent)]
                         [(ada-indent-record* 'TYPE 1 ada-indent) (ada-indent-record* 'TYPE 1 ada-indent)]
                         (ada-indent-record* 'TYPE 1 0)
                         nil]))%
 ;; ' terminate quote
  | NULL RECORD
  ;

record_representation_clause
  : FOR name USE RECORD mod_clause_opt component_clause_list END RECORD SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-face-apply-action [2 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken
                             (ada-indent-record 1 4 0)
                             (ada-indent-record 1 4 ada-indent)
                             (ada-indent-record 1 4 ada-indent)
                             (ada-indent-record 1 4 0)
                             nil nil])))%
  ;

relation_and_list
  : relation_and_list AND relation
  | relation AND relation
  ;

relation_and_then_list
  : relation_and_then_list AND THEN relation
  | relation AND THEN relation
  ;

relation_or_list
  : relation_or_list OR relation
  | relation OR relation
  ;

relation_or_else_list
  : relation_or_else_list OR ELSE relation
  | relation OR ELSE relation
  ;

relation_xor_list
  : relation_xor_list XOR relation
  | relation XOR relation
  ;

;; http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ai12s/ai12-0022-1.txt?rev=1.13
;; adds raise_expression
relation
  : simple_expression NOT IN membership_choice_list
  | simple_expression IN membership_choice_list
  | simple_expression relational_operator simple_expression
  | simple_expression
  | raise_expression
  ;

relational_operator
  : EQUAL | SLASH_EQUAL | LESS | LESS_EQUAL | GREATER | GREATER_EQUAL ;
  ;;  =   | /=          | <    |  <=        | >       | >=

renaming_declaration
  : object_renaming_declaration ;; includes exception_renaming_declaration
  | package_renaming_declaration
  | subprogram_renaming_declaration
  | generic_renaming_declaration
  ;

requeue_statement
  : REQUEUE name WITH ABORT SEMICOLON
    %((wisi-statement-action [1 statement-start 5 statement-end]))%
  | REQUEUE name SEMICOLON
    %((wisi-statement-action [1 statement-start 3 statement-end]))%
  ;

;; not in LRM; used to implement consistent indentation
result_profile
  : RETURN null_exclusion_opt name_opt
    %((progn
      (wisi-face-apply-action [3 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action* 1
                           [nil
                            (wisi-anchored* 1 ada-indent-broken)
                            (wisi-anchored* 1 ada-indent-broken)])))%
  | RETURN access_definition
 ;; test/ada_mode-nominal.adb
 ;; function Function_Access_1
 ;;   (A_Param : in Float)
 ;;   return access
 ;;     Standard.Float
    %((wisi-indent-action* 1 [nil (wisi-anchored*- 1 ada-indent-broken)]))%
  ;

return_subtype_indication
  : subtype_indication
  | access_definition
  ;

selected_component
  : name DOT IDENTIFIER
    %((wisi-face-mark-action [1 prefix 3 suffix]))%
    %((wisi-merge-names 1 3))%

  | name DOT CHARACTER_LITERAL
    %((wisi-face-mark-action [1 prefix]))%

  | name DOT STRING_LITERAL
    %((wisi-face-mark-action [1 prefix]))%
    %((wisi-merge-names 1 3))%

  | name DOT ALL
    %((wisi-face-mark-action [1 prefix]))%
  ;

;; selector_name - IDENTIFIER, STRING_LITERAL overlap name; CHARACTER_LITERAL used separately
;;  : IDENTIFIER | CHARACTER_LITERAL | STRING_LITERAL ; ;; operator_symbol

selective_accept
  : SELECT select_alternative_list_opt ELSE sequence_of_statements_opt END SELECT SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 7 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 4)
      (wisi-motion-action [1 [2 OR WHEN] 3 7])
      (wisi-indent-action [[nil ada-indent] [nil ada-indent] nil [ada-indent ada-indent] nil nil nil])))%
  | SELECT select_alternative_list_opt END SELECT SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-motion-action [1 [2 OR WHEN] 5])
      (wisi-indent-action [[nil ada-indent] [nil ada-indent] nil nil nil])))%
  ;

select_alternative
 ;; we can't use guard_opt here because when present a guard is a
 ;; block-start, but when absent there is no block-start
  : WHEN expression_opt EQUAL_GREATER accept_statement sequence_of_statements_opt ;; guard accept_alternative
    %((progn
      (wisi-statement-action [1 motion])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent ada-indent])))%
  | WHEN expression_opt EQUAL_GREATER TERMINATE SEMICOLON ;; terminate_alternative
    %((progn
      (wisi-statement-action [1 motion 4 statement-start 5 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent nil])))%
  | WHEN expression_opt EQUAL_GREATER delay_alternative
    %((progn
      (wisi-statement-action [1 motion])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent])))%
  | accept_statement sequence_of_statements_opt ;; accept_alternative
  | TERMINATE SEMICOLON ;; terminate_alternative
    %((wisi-statement-action [1 statement-start 2 statement-end]))%
  | delay_alternative
  ;

select_alternative_list
  : select_alternative_list OR select_alternative
    %((progn
      (wisi-statement-action [2 motion])
      (wisi-indent-action [nil nil ada-indent])))%
  | select_alternative
    %((wisi-indent-action [ada-indent]))%
  ;

select_alternative_list_opt
  : select_alternative_list
  | ;; empty
  ;

select_statement
  : selective_accept
  | timed_entry_call
  | conditional_entry_call
  | asynchronous_select
  ;

sequence_of_statements
  : sequence_of_statements statement
  | statement
  ;

;; Wherever the ARM requires a sequence_of_statements, we allow
;; nothing; this simplifies indenting skeletons (see ada-skel), and is
;; more user-friendly for indenting while editing.
sequence_of_statements_opt
  : sequence_of_statements
  | ;; empty
  ;

simple_expression
  : unary_adding_operator term_list
  | term_list
  ;

simple_return_statement
  : RETURN expression_opt SEMICOLON
 ;; test/ada_mode-parens.adb Function_3
 ;; return
 ;;   1.0 +
 ;;   2.0;
    %((progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-containing-action 1 2)
      (wisi-indent-action [nil ada-indent-broken nil])))%
  ;

simple_statement
  : NULL SEMICOLON;; null_statement
    %((wisi-statement-action [1 statement-start 2 statement-end]))%
  | assignment_statement
  | exit_statement
  | GOTO IDENTIFIER SEMICOLON ;; goto_statement
    %((progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-face-apply-action [2 nil font-lock-constant-face])))%
  | procedure_call_statement
  | simple_return_statement
 ;; | entry_call_statement ; covered by procedure_call_statement
  | requeue_statement
  | delay_statement
  | ABORT name SEMICOLON ;; abort_statement; ignoring list of tasks
    %((wisi-statement-action [1 statement-start 3 statement-end]))%
  | raise_statement
  ;; | code_statement
  | pragma_g
  ;

single_protected_declaration
  : PROTECTED IDENTIFIER aspect_specification_opt IS NEW interface_list WITH protected_definition SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 4 motion 7 motion 9 statement-end])
        (wisi-name-action 2)
        (wisi-containing-action 1 8)
        (wisi-motion-action [1 4 7 [8 PRIVATE] 9])
        (wisi-face-apply-action [2 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken nil nil ada-indent-broken ada-indent-broken ada-indent-broken nil
                                 nil])))%
    %((wisi-match-names 2 8))%

  | PROTECTED IDENTIFIER aspect_specification_opt IS protected_definition SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 4 motion 6 statement-end])
        (wisi-name-action 2)
        (wisi-containing-action 1 5)
        (wisi-motion-action [1 4 [5 PRIVATE] 6])
        (wisi-face-apply-action [2 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken nil [nil ada-indent] nil nil])))%
    %((wisi-match-names 2 5))%
  ;

single_task_declaration
  : TASK IDENTIFIER aspect_specification_opt IS NEW interface_list WITH task_definition END identifier_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 4 motion 7 motion 11 statement-end])
        (wisi-name-action 2)
        (wisi-containing-action 1 8)
        (wisi-motion-action [1 4 [8 PRIVATE] 11])
        (wisi-face-apply-action [2 nil font-lock-type-face 9 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken nil nil ada-indent-broken ada-indent-broken ada-indent-broken nil
                                 nil nil nil])))%
    %((wisi-match-names 2 10))%

  | TASK IDENTIFIER aspect_specification_opt IS task_definition END identifier_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 4 motion 8 statement-end])
        (wisi-name-action 2)
        (wisi-containing-action 1 5)
        (wisi-motion-action [1 4 [5 PRIVATE] 8])
        (wisi-face-apply-action [2 nil font-lock-type-face 6 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken nil [nil ada-indent] nil nil nil nil])))%
    %((wisi-match-names 2 7))%

  | TASK IDENTIFIER aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 4 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken nil nil])))%
  ;

statement
  : goto_label
  | simple_statement
  | compound_statement
  ;

subprogram_body
  : overriding_indicator_opt subprogram_specification aspect_specification_opt IS declarative_part_opt
    BEGIN handled_sequence_of_statements END name_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 statement-override 4 motion 6 motion 10 statement-end])
      (wisi-containing-action 2 4)
      (wisi-containing-action 4 5) ;; for goto_declarative_region_start
      (wisi-containing-action 2 7)
      (wisi-motion-action [1 [2 FUNCTION PROCEDURE] 4 6 10])
      (wisi-face-apply-action [9 font-lock-function-name-face font-lock-function-name-face])
      (wisi-indent-action [nil [nil ada-indent] nil nil [ada-indent ada-indent]
                             nil [ada-indent ada-indent] nil ada-indent-broken nil])))%
    %((wisi-match-names 2 9))%
  ;

subprogram_body_stub
  : overriding_indicator_opt subprogram_specification IS SEPARATE aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 statement-override 6 statement-end])
      (wisi-indent-action [nil nil nil ada-indent-broken ada-indent-broken nil])))%
  ;

subprogram_declaration
  : overriding_indicator_opt subprogram_specification aspect_specification_opt SEMICOLON
    %((wisi-statement-action [1 statement-start 2 statement-override 4 statement-end]))%
  ;

subprogram_default
  : name
    %((wisi-face-apply-action [1 font-lock-function-name-face font-lock-function-name-face]))%
  | BOX
  | NULL ;

subprogram_renaming_declaration
  : overriding_indicator_opt subprogram_specification RENAMES name aspect_specification_opt SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 2 statement-override 6 statement-end])
      (wisi-face-apply-action [4 font-lock-function-name-face font-lock-function-name-face])
      (wisi-indent-action [nil nil (ada-indent-renames 2) ada-indent-broken ada-indent-broken nil])))%
  ;

subprogram_specification
  : procedure_specification
    %()%
    %((wisi-propagate-name 1))%
  | function_specification
    %()%
    %((wisi-propagate-name 1))%
  ;

subtype_declaration
  : SUBTYPE IDENTIFIER IS subtype_indication aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 6 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil nil])))%
  ;

subtype_indication
  : NOT NULL name constraint
 ;; The last component of a selected_component could be an iterator
 ;; function in a loop iteration_scheme, not a type. See the comment
 ;; in iterator_specification.
    %((wisi-face-apply-action [3 font-lock-function-name-face font-lock-type-face]))%
  | NOT NULL name
    %((wisi-face-apply-action [3 font-lock-function-name-face font-lock-type-face]))%
  | name constraint
    %((wisi-face-apply-action [1 font-lock-function-name-face font-lock-type-face]))%
  | name
    %((wisi-face-apply-action [1 font-lock-function-name-face font-lock-type-face]))%
  ;

;; subtype_mark replaced by name

subunit
  : SEPARATE LEFT_PAREN name RIGHT_PAREN proper_body
    %((progn
      (wisi-statement-action [1 statement-start 5 motion])
      (wisi-indent-action [nil ada-indent-broken (wisi-anchored 2 1) (wisi-anchored 2 0) nil])))%
  ;

task_body
  : TASK BODY IDENTIFIER aspect_specification_opt IS declarative_part_opt
    BEGIN handled_sequence_of_statements END identifier_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 5 motion 7 motion 11 statement-end])
        (wisi-name-action 3)
        (wisi-containing-action 1 6)
        (wisi-containing-action 1 8)
        (wisi-motion-action [1 5 7 11])
        (wisi-face-apply-action [3 nil font-lock-type-face 10 nil font-lock-type-face])
        (wisi-indent-action [nil nil ada-indent-broken nil nil [ada-indent ada-indent]
                               nil [ada-indent ada-indent] nil nil nil])))%
    %((wisi-match-names 3 10))%
  ;

task_body_stub
  : TASK BODY IDENTIFIER IS SEPARATE aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 nil font-lock-type-face])
        (wisi-indent-action [nil nil ada-indent-broken nil ada-indent-broken ada-indent-broken nil])))%
  ;

;; LRM includes 'end identifier' here; we put that in
;; task_type_declaration, single_task_declaration to simplify motion
;; actions.
task_definition
  : declarative_part_opt PRIVATE declarative_part_opt
    %((progn
      (wisi-statement-action [2 motion])
      (wisi-containing-action 2 3)
      (wisi-indent-action [[ada-indent ada-indent] nil [ada-indent ada-indent]])))%
  | declarative_part_opt
    %((wisi-indent-action [[ada-indent ada-indent]]))%
  ;

;; task_item replaced by declaration

task_type_declaration
  : TASK TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt IS
    NEW interface_list WITH task_definition END identifier_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 6 motion 9 motion 13 statement-end])
        (wisi-name-action 3)
        (wisi-containing-action 1 10)
        (wisi-motion-action [1 6 9 [10 PRIVATE] 13])
        (wisi-face-apply-action [3 nil font-lock-type-face 12 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil nil
                               ada-indent-broken ada-indent-broken ada-indent-broken nil nil nil nil])))%
    %((wisi-match-names 3 12))%
  | TASK TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt IS task_definition END identifier_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 6 motion 10 statement-end])
        (wisi-name-action 3)
        (wisi-containing-action 1 7)
        (wisi-face-apply-action [3 nil font-lock-type-face 9 nil font-lock-type-face])
        (wisi-motion-action [1 6 [7 PRIVATE] 10])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil [nil ada-indent] nil nil nil
                                 nil])))%
    %((wisi-match-names 3 9))%

  | TASK TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt SEMICOLON
    %((progn
        (wisi-statement-action [1 statement-start 6 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken nil nil])))%
  ;

term
  : term multiplying_operator factor
  | factor
  ;

term_list
  : term_list binary_adding_operator term
  | term
  ;

tick
  : TICK_1
%if lexer = re2c
  | TICK_2
%end if
  ;

timed_entry_call
  : SELECT entry_call_alternative OR delay_alternative END SELECT SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 motion 6 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 4)
      (wisi-indent-action [nil [ada-indent ada-indent] nil [ada-indent ada-indent] nil nil nil])))%
  ;

triggering_alternative
  : procedure_call_statement sequence_of_statements_opt
  | name sequence_of_statements_opt ;; entry_call_statement
  | delay_statement sequence_of_statements_opt
  ;

type_declaration
  : full_type_declaration
  | incomplete_type_declaration
  | private_type_declaration
  | private_extension_declaration
  ;

type_definition
  : enumeration_type_definition
  | RANGE simple_expression DOT_DOT simple_expression ;; integer_type_definition
  | MOD expression_opt
  | DIGITS expression_opt real_range_specification_opt ;; real_type_definition, floating_point_type_definition
  | DELTA expression_opt DIGITS expression_opt real_range_specification_opt ;; decimal_fixed_point_definition
  | DELTA expression_opt real_range_specification_opt ;; ordinary_fixed_point_definition
  | array_type_definition
  | abstract_tagged_limited_opt record_definition ;;record_type_definition
  | access_definition ;; access_type_definition
  | derived_type_definition
  | interface_type_definition
  ;

variant_part
  : CASE direct_name_opt IS variant_list END CASE SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 1 4) ;; for goto-declaration-start
      (wisi-indent-action [nil ada-indent-broken nil ada-indent-when nil nil nil])))%
  ;

variant_list
  : variant_list variant
  | variant
  ;

variant
  : WHEN discrete_choice_list EQUAL_GREATER component_list_opt
    %((progn
      (wisi-statement-action [1 motion])
      ;; ada-indent-when applied in variant_part
      (wisi-indent-action [nil (wisi-hanging nil ada-indent-broken) ada-indent [ada-indent ada-indent]])))%
  ;

unary_adding_operator : PLUS | MINUS ; ;; + | -

use_clause
  : USE ALL TYPE name_list SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-face-apply-list-action [4 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-use nil])))%
  | USE TYPE name_list SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-face-apply-list-action [3 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-use nil])))%
  | USE name_list SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-face-apply-list-action [2 font-lock-function-name-face font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-use nil])))%
  ;

with_clause
  : LIMITED PRIVATE WITH name_list SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-face-apply-list-action [4 font-lock-function-name-face font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-with nil])))%
  | LIMITED WITH name_list SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-face-apply-list-action [3 font-lock-function-name-face font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-with nil])))%
  | PRIVATE WITH name_list SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-face-apply-list-action [3 font-lock-function-name-face font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-with nil])))%
  | WITH name_list SEMICOLON
    %((progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-face-apply-list-action [2 font-lock-function-name-face font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-with nil])))%
  ;

;;; end of file
